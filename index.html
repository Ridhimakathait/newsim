<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ML/LLM CPU Scheduling Simulator</title>
    
    <!-- 
      Embedded Styles from style.css
      I've placed all your original CSS rules here.
    -->
    <style>
      :root {
        /* Primitive Color Tokens */
        --color-white: rgba(255, 255, 255, 1);
        --color-black: rgba(0, 0, 0, 1);
        --color-cream-50: rgba(252, 252, 249, 1);
        --color-cream-100: rgba(255, 255, 253, 1);
        --color-gray-200: rgba(245, 245, 245, 1);
        --color-gray-300: rgba(167, 169, 169, 1);
        --color-gray-400: rgba(119, 124, 124, 1);
        --color-slate-500: rgba(98, 108, 113, 1);
        --color-brown-600: rgba(94, 82, 64, 1);
        --color-charcoal-700: rgba(31, 33, 33, 1);
        --color-charcoal-800: rgba(38, 40, 40, 1);
        --color-slate-900: rgba(19, 52, 59, 1);
        --color-teal-300: rgba(50, 184, 198, 1);
        --color-teal-400: rgba(45, 166, 178, 1);
        --color-teal-500: rgba(33, 128, 141, 1);
        --color-teal-600: rgba(29, 116, 128, 1);
        --color-teal-700: rgba(26, 104, 115, 1);
        --color-teal-800: rgba(41, 150, 161, 1);
        --color-red-400: rgba(255, 84, 89, 1);
        --color-red-500: rgba(192, 21, 47, 1);
        --color-orange-400: rgba(230, 129, 97, 1);
        --color-orange-500: rgba(168, 75, 47, 1);

        /* RGB versions for opacity control */
        --color-brown-600-rgb: 94, 82, 64;
        --color-teal-500-rgb: 33, 128, 141;
        --color-slate-900-rgb: 19, 52, 59;
        --color-slate-500-rgb: 98, 108, 113;
        --color-red-500-rgb: 192, 21, 47;
        --color-red-400-rgb: 255, 84, 89;
        --color-orange-500-rgb: 168, 75, 47;
        --color-orange-400-rgb: 230, 129, 97;

        /* Background color tokens (Light Mode) */
        --color-bg-1: rgba(59, 130, 246, 0.08); /* Light blue */
        --color-bg-2: rgba(245, 158, 11, 0.08); /* Light yellow */
        --color-bg-3: rgba(34, 197, 94, 0.08); /* Light green */
        --color-bg-4: rgba(239, 68, 68, 0.08); /* Light red */
        --color-bg-5: rgba(147, 51, 234, 0.08); /* Light purple */
        --color-bg-6: rgba(249, 115, 22, 0.08); /* Light orange */
        --color-bg-7: rgba(236, 72, 153, 0.08); /* Light pink */
        --color-bg-8: rgba(6, 182, 212, 0.08); /* Light cyan */

        /* Semantic Color Tokens (Light Mode) */
        --color-background: var(--color-cream-50);
        --color-surface: var(--color-cream-100);
        --color-text: var(--color-slate-900);
        --color-text-secondary: var(--color-slate-500);
        --color-primary: var(--color-teal-500);
        --color-primary-hover: var(--color-teal-600);
        --color-primary-active: var(--color-teal-700);
        --color-secondary: rgba(var(--color-brown-600-rgb), 0.12);
        --color-secondary-hover: rgba(var(--color-brown-600-rgb), 0.2);
        --color-secondary-active: rgba(var(--color-brown-600-rgb), 0.25);
        --color-border: rgba(var(--color-brown-600-rgb), 0.2);
        --color-btn-primary-text: var(--color-cream-50);
        --color-card-border: rgba(var(--color-brown-600-rgb), 0.12);
        --color-card-border-inner: rgba(var(--color-brown-600-rgb), 0.12);
        --color-error: var(--color-red-500);
        --color-success: var(--color-teal-500);
        --color-warning: var(--color-orange-500);
        --color-info: var(--color-slate-500);
        --color-focus-ring: rgba(var(--color-teal-500-rgb), 0.4);
        --color-select-caret: rgba(var(--color-slate-900-rgb), 0.8);

        /* Common style patterns */
        --focus-ring: 0 0 0 3px var(--color-focus-ring);
        --focus-outline: 2px solid var(--color-primary);
        --status-bg-opacity: 0.15;
        --status-border-opacity: 0.25;
        --select-caret-light: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23134252' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
        --select-caret-dark: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23f5f5f5' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");

        /* RGB versions for opacity control */
        --color-success-rgb: 33, 128, 141;
        --color-error-rgb: 192, 21, 47;
        --color-warning-rgb: 168, 75, 47;
        --color-info-rgb: 98, 108, 113;

        /* Typography */
        --font-family-base: "FKGroteskNeue", "Geist", "Inter", -apple-system,
          BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        --font-family-mono: "Berkeley Mono", ui-monospace, SFMono-Regular, Menlo,
          Monaco, Consolas, monospace;
        --font-size-xs: 11px;
        --font-size-sm: 12px;
        --font-size-base: 14px;
        --font-size-md: 14px;
        --font-size-lg: 16px;
        --font-size-xl: 18px;
        --font-size-2xl: 20px;
        --font-size-3xl: 24px;
        --font-size-4xl: 30px;
        --font-weight-normal: 400;
        --font-weight-medium: 500;
        --font-weight-semibold: 550;
        --font-weight-bold: 600;
        --line-height-tight: 1.2;
        --line-height-normal: 1.5;
        --letter-spacing-tight: -0.01em;

        /* Spacing */
        --space-0: 0;
        --space-1: 1px;
        --space-2: 2px;
        --space-4: 4px;
        --space-6: 6px;
        --space-8: 8px;
        --space-10: 10px;
        --space-12: 12px;
        --space-16: 16px;
        --space-20: 20px;
        --space-24: 24px;
        --space-32: 32px;

        /* Border Radius */
        --radius-sm: 6px;
        --radius-base: 8px;
        --radius-md: 10px;
        --radius-lg: 12px;
        --radius-full: 9999px;

        /* Shadows */
        --shadow-xs: 0 1px 2px rgba(0, 0, 0, 0.02);
        --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.04), 0 1px 2px rgba(0, 0, 0, 0.02);
        --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.04),
          0 2px 4px -1px rgba(0, 0, 0, 0.02);
        --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.04),
          0 4px 6px -2px rgba(0, 0, 0, 0.02);
        --shadow-inset-sm: inset 0 1px 0 rgba(255, 255, 255, 0.15),
          inset 0 -1px 0 rgba(0, 0, 0, 0.03);

        /* Animation */
        --duration-fast: 150ms;
        --duration-normal: 250ms;
        --ease-standard: cubic-bezier(0.16, 1, 0.3, 1);

        /* Layout */
        --container-sm: 640px;
        --container-md: 768px;
        --container-lg: 1024px;
        --container-xl: 1280px;
      }

      /* Dark mode colors */
      @media (prefers-color-scheme: dark) {
        :root {
          /* RGB versions for opacity control (Dark Mode) */
          --color-gray-400-rgb: 119, 124, 124;
          --color-teal-300-rgb: 50, 184, 198;
          --color-gray-300-rgb: 167, 169, 169;
          --color-gray-200-rgb: 245, 245, 245;

          /* Background color tokens (Dark Mode) */
          --color-bg-1: rgba(29, 78, 216, 0.15); /* Dark blue */
          --color-bg-2: rgba(180, 83, 9, 0.15); /* Dark yellow */
          --color-bg-3: rgba(21, 128, 61, 0.15); /* Dark green */
          --color-bg-4: rgba(185, 28, 28, 0.15); /* Dark red */
          --color-bg-5: rgba(107, 33, 168, 0.15); /* Dark purple */
          --color-bg-6: rgba(194, 65, 12, 0.15); /* Dark orange */
          --color-bg-7: rgba(190, 24, 93, 0.15); /* Dark pink */
          --color-bg-8: rgba(8, 145, 178, 0.15); /* Dark cyan */

          /* Semantic Color Tokens (Dark Mode) */
          --color-background: var(--color-charcoal-700);
          --color-surface: var(--color-charcoal-800);
          --color-text: var(--color-gray-200);
          --color-text-secondary: rgba(var(--color-gray-300-rgb), 0.7);
          --color-primary: var(--color-teal-300);
          --color-primary-hover: var(--color-teal-400);
          --color-primary-active: var(--color-teal-800);
          --color-secondary: rgba(var(--color-gray-400-rgb), 0.15);
          --color-secondary-hover: rgba(var(--color-gray-400-rgb), 0.25);
          --color-secondary-active: rgba(var(--color-gray-400-rgb), 0.3);
          --color-border: rgba(var(--color-gray-400-rgb), 0.3);
          --color-error: var(--color-red-400);
          --color-success: var(--color-teal-300);
          --color-warning: var(--color-orange-400);
          --color-info: var(--color-gray-300);
          --color-focus-ring: rgba(var(--color-teal-300-rgb), 0.4);
          --color-btn-primary-text: var(--color-slate-900);
          --color-card-border: rgba(var(--color-gray-400-rgb), 0.2);
          --color-card-border-inner: rgba(var(--color-gray-400-rgb), 0.15);
          --shadow-inset-sm: inset 0 1px 0 rgba(255, 255, 255, 0.1),
            inset 0 -1px 0 rgba(0, 0, 0, 0.15);
          --button-border-secondary: rgba(var(--color-gray-400-rgb), 0.2);
          --color-border-secondary: rgba(var(--color-gray-400-rgb), 0.2);
          --color-select-caret: rgba(var(--color-gray-200-rgb), 0.8);

          /* Common style patterns - updated for dark mode */
          --focus-ring: 0 0 0 3px var(--color-focus-ring);
          --focus-outline: 2px solid var(--color-primary);
          --status-bg-opacity: 0.15;
          --status-border-opacity: 0.25;
          --select-caret-light: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23134252' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
          --select-caret-dark: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23f5f5f5' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");

          /* RGB versions for dark mode */
          --color-success-rgb: var(--color-teal-300-rgb);
          --color-error-rgb: var(--color-red-400-rgb);
          --color-warning-rgb: var(--color-orange-400-rgb);
          --color-info-rgb: var(--color-gray-300-rgb);
        }
      }

      /* Data attribute for manual theme switching */
      [data-color-scheme="dark"] {
        /* RGB versions for opacity control (dark mode) */
        --color-gray-400-rgb: 119, 124, 124;
        --color-teal-300-rgb: 50, 184, 198;
        --color-gray-300-rgb: 167, 169, 169;
        --color-gray-200-rgb: 245, 245, 245;

        /* Colorful background palette - Dark Mode */
        --color-bg-1: rgba(29, 78, 216, 0.15); /* Dark blue */
        --color-bg-2: rgba(180, 83, 9, 0.15); /* Dark yellow */
        --color-bg-3: rgba(21, 128, 61, 0.15); /* Dark green */
        --color-bg-4: rgba(185, 28, 28, 0.15); /* Dark red */
        --color-bg-5: rgba(107, 33, 168, 0.15); /* Dark purple */
        --color-bg-6: rgba(194, 65, 12, 0.15); /* Dark orange */
        --color-bg-7: rgba(190, 24, 93, 0.15); /* Dark pink */
        --color-bg-8: rgba(8, 145, 178, 0.15); /* Dark cyan */

        /* Semantic Color Tokens (Dark Mode) */
        --color-background: var(--color-charcoal-700);
        --color-surface: var(--color-charcoal-800);
        --color-text: var(--color-gray-200);
        --color-text-secondary: rgba(var(--color-gray-300-rgb), 0.7);
        --color-primary: var(--color-teal-300);
        --color-primary-hover: var(--color-teal-400);
        --color-primary-active: var(--color-teal-800);
        --color-secondary: rgba(var(--color-gray-400-rgb), 0.15);
        --color-secondary-hover: rgba(var(--color-gray-400-rgb), 0.25);
        --color-secondary-active: rgba(var(--color-gray-400-rgb), 0.3);
        --color-border: rgba(var(--color-gray-400-rgb), 0.3);
        --color-error: var(--color-red-400);
        --color-success: var(--color-teal-300);
        --color-warning: var(--color-orange-400);
        --color-info: var(--color-gray-300);
        --color-focus-ring: rgba(var(--color-teal-300-rgb), 0.4);
        --color-btn-primary-text: var(--color-slate-900);
        --color-card-border: rgba(var(--color-gray-400-rgb), 0.15);
        --color-card-border-inner: rgba(var(--color-gray-400-rgb), 0.15);
        --shadow-inset-sm: inset 0 1px 0 rgba(255, 255, 255, 0.1),
          inset 0 -1px 0 rgba(0, 0, 0, 0.15);
        --color-border-secondary: rgba(var(--color-gray-400-rgb), 0.2);
        --color-select-caret: rgba(var(--color-gray-200-rgb), 0.8);

        /* Common style patterns - updated for dark mode */
        --focus-ring: 0 0 0 3px var(--color-focus-ring);
        --focus-outline: 2px solid var(--color-primary);
        --status-bg-opacity: 0.15;
        --status-border-opacity: 0.25;
        --select-caret-light: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23134252' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
        --select-caret-dark: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23f5f5f5' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");

        /* RGB versions for dark mode */
        --color-success-rgb: var(--color-teal-300-rgb);
        --color-error-rgb: var(--color-red-400-rgb);
        --color-warning-rgb: var(--color-orange-400-rgb);
        --color-info-rgb: var(--color-gray-300-rgb);
      }

      [data-color-scheme="light"] {
        /* RGB versions for opacity control (light mode) */
        --color-brown-600-rgb: 94, 82, 64;
        --color-teal-500-rgb: 33, 128, 141;
        --color-slate-900-rgb: 19, 52, 59;

        /* Semantic Color Tokens (Light Mode) */
        --color-background: var(--color-cream-50);
        --color-surface: var(--color-cream-100);
        --color-text: var(--color-slate-900);
        --color-text-secondary: var(--color-slate-500);
        --color-primary: var(--color-teal-500);
        --color-primary-hover: var(--color-teal-600);
        --color-primary-active: var(--color-teal-700);
        --color-secondary: rgba(var(--color-brown-600-rgb), 0.12);
        --color-secondary-hover: rgba(var(--color-brown-600-rgb), 0.2);
        --color-secondary-active: rgba(var(--color-brown-600-rgb), 0.25);
        --color-border: rgba(var(--color-brown-600-rgb), 0.2);
        --color-btn-primary-text: var(--color-cream-50);
        --color-card-border: rgba(var(--color-brown-600-rgb), 0.12);
        --color-card-border-inner: rgba(var(--color-brown-600-rgb), 0.12);
        --color-error: var(--color-red-500);
        --color-success: var(--color-teal-500);
        --color-warning: var(--color-orange-500);
        --color-info: var(--color-slate-500);
        --color-focus-ring: rgba(var(--color-teal-500-rgb), 0.4);

        /* RGB versions for light mode */
        --color-success-rgb: var(--color-teal-500-rgb);
        --color-error-rgb: var(--color-red-500-rgb);
        --color-warning-rgb: var(--color-orange-500-rgb);
        --color-info-rgb: var(--color-slate-500-rgb);
      }

      /* Base styles */
      html {
        font-size: var(--font-size-base);
        font-family: var(--font-family-base);
        line-height: var(--line-height-normal);
        color: var(--color-text);
        background-color: var(--color-background);
        -webkit-font-smoothing: antialiased;
        box-sizing: border-box;
      }

      body {
        margin: 0;
        padding: 0;
      }

      *,
      *::before,
      *::after {
        box-sizing: inherit;
      }

      /* Typography */
      h1,
      h2,
      h3,
      h4,
      h5,
      h6 {
        margin: 0;
        font-weight: var(--font-weight-semibold);
        line-height: var(--line-height-tight);
        color: var(--color-text);
        letter-spacing: var(--letter-spacing-tight);
      }

      h1 {
        font-size: var(--font-size-4xl);
      }
      h2 {
        font-size: var(--font-size-3xl);
      }
      h3 {
        font-size: var(--font-size-2xl);
      }
      h4 {
        font-size: var(--font-size-xl);
      }
      h5 {
        font-size: var(--font-size-lg);
      }
      h6 {
        font-size: var(--font-size-md);
      }

      p {
        margin: 0 0 var(--space-16) 0;
      }
      
      #llmAnalysisResult p {
        margin: 0 0 var(--space-12) 0;
      }
      
      #llmAnalysisResult h3 {
         margin-top: var(--space-16);
         margin-bottom: var(--space-8);
      }
      
      #llmAnalysisResult h4 {
         margin-top: var(--space-12);
         margin-bottom: var(--space-8);
      }
      
      #llmAnalysisResult ul {
        margin: 0 0 var(--space-12) var(--space-20);
        padding: 0;
      }
      
      #llmAnalysisResult li {
         margin-bottom: var(--space-4);
      }

      a {
        color: var(--color-primary);
        text-decoration: none;
        transition: color var(--duration-fast) var(--ease-standard);
      }

      a:hover {
        color: var(--color-primary-hover);
      }

      code,
      pre {
        font-family: var(--font-family-mono);
        font-size: calc(var(--font-size-base) * 0.95);
        background-color: var(--color-secondary);
        border-radius: var(--radius-sm);
      }

      code {
        padding: var(--space-1) var(--space-4);
      }

      pre {
        padding: var(--space-16);
        margin: var(--space-16) 0;
        overflow: auto;
        border: 1px solid var(--color-border);
      }

      pre code {
        background: none;
        padding: 0;
      }

      /* Buttons */
      .btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: var(--space-8) var(--space-16);
        border-radius: var(--radius-base);
        font-size: var(--font-size-base);
        font-weight: 500;
        line-height: 1.5;
        cursor: pointer;
        transition: all var(--duration-normal) var(--ease-standard);
        border: none;
        text-decoration: none;
        position: relative;
      }

      .btn:focus-visible {
        outline: none;
        box-shadow: var(--focus-ring);
      }

      .btn--primary {
        background: var(--color-primary);
        color: var(--color-btn-primary-text);
      }

      .btn--primary:hover {
        background: var(--color-primary-hover);
      }

      .btn--primary:active {
        background: var(--color-primary-active);
      }

      .btn--secondary {
        background: var(--color-secondary);
        color: var(--color-text);
      }

      .btn--secondary:hover {
        background: var(--color-secondary-hover);
      }

      .btn--secondary:active {
        background: var(--color-secondary-active);
      }

      .btn--outline {
        background: transparent;
        border: 1px solid var(--color-border);
        color: var(--color-text);
      }

      .btn--outline:hover {
        background: var(--color-secondary);
      }

      .btn--sm {
        padding: var(--space-4) var(--space-12);
        font-size: var(--font-size-sm);
        border-radius: var(--radius-sm);
      }

      .btn--lg {
        padding: var(--space-10) var(--space-20);
        font-size: var(--font-size-lg);
        border-radius: var(--radius-md);
      }

      .btn--full-width {
        width: 100%;
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      /* Form elements */
      .form-control {
        display: block;
        width: 100%;
        padding: var(--space-8) var(--space-12);
        font-size: var(--font-size-md);
        line-height: 1.5;
        color: var(--color-text);
        background-color: var(--color-surface);
        border: 1px solid var(--color-border);
        border-radius: var(--radius-base);
        transition: border-color var(--duration-fast) var(--ease-standard),
          box-shadow var(--duration-fast) var(--ease-standard);
      }

      textarea.form-control {
        font-family: var(--font-family-base);
        font-size: var(--font-size-base);
      }

      select.form-control {
        padding: var(--space-8) var(--space-12);
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        background-image: var(--select-caret-light);
        background-repeat: no-repeat;
        background-position: right var(--space-12) center;
        background-size: 16px;
        padding-right: var(--space-32);
      }

      /* Add a dark mode specific caret */
      @media (prefers-color-scheme: dark) {
        select.form-control {
          background-image: var(--select-caret-dark);
        }
      }

      /* Also handle data-color-scheme */
      [data-color-scheme="dark"] select.form-control {
        background-image: var(--select-caret-dark);
      }

      [data-color-scheme="light"] select.form-control {
        background-image: var(--select-caret-light);
      }

      .form-control:focus {
        border-color: var(--color-primary);
        outline: var(--focus-outline);
      }

      .form-label {
        display: block;
        margin-bottom: var(--space-8);
        font-weight: var(--font-weight-medium);
        font-size: var(--font-size-sm);
      }

      .form-group {
        margin-bottom: var(--space-16);
      }

      /* Card component */
      .card {
        background-color: var(--color-surface);
        border-radius: var(--radius-lg);
        border: 1px solid var(--color-card-border);
        box-shadow: var(--shadow-sm);
        overflow: hidden;
        transition: box-shadow var(--duration-normal) var(--ease-standard);
        margin-bottom: var(--space-24);
      }

      .card:hover {
        box-shadow: var(--shadow-md);
      }

      .card__body {
        padding: var(--space-16);
      }

      .card__header {
        padding: var(--space-16);
        border-bottom: 1px solid var(--color-card-border-inner);
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: var(--space-12);
      }
      
      .card__header h2 {
         font-size: var(--font-size-2xl); /* Slightly smaller than h2 for card headers */
      }


      /* Status indicators - simplified with CSS variables */
      .status {
        display: inline-flex;
        align-items: center;
        padding: var(--space-6) var(--space-12);
        border-radius: var(--radius-full);
        font-weight: var(--font-weight-medium);
        font-size: var(--font-size-sm);
        width: 100%;
      }

      .status--success {
        background-color: rgba(
          var(--color-success-rgb, 33, 128, 141),
          var(--status-bg-opacity)
        );
        color: var(--color-success);
        border: 1px solid
          rgba(var(--color-success-rgb, 33, 128, 141), var(--status-border-opacity));
      }

      .status--error {
        background-color: rgba(
          var(--color-error-rgb, 192, 21, 47),
          var(--status-bg-opacity)
        );
        color: var(--color-error);
        border: 1px solid
          rgba(var(--color-error-rgb, 192, 21, 47), var(--status-border-opacity));
      }

      .status--warning {
        background-color: rgba(
          var(--color-warning-rgb, 168, 75, 47),
          var(--status-bg-opacity)
        );
        color: var(--color-warning);
        border: 1px solid
          rgba(var(--color-warning-rgb, 168, 75, 47), var(--status-border-opacity));
      }

      .status--info {
        background-color: rgba(
          var(--color-info-rgb, 98, 108, 113),
          var(--status-bg-opacity)
        );
        color: var(--color-info);
        border: 1px solid
          rgba(var(--color-info-rgb, 98, 108, 113), var(--status-border-opacity));
      }

      /* Container layout */
      .container {
        width: 100%;
        margin-right: auto;
        margin-left: auto;
        padding-right: var(--space-16);
        padding-left: var(--space-16);
      }

      @media (min-width: 640px) {
        .container {
          max-width: var(--container-sm);
        }
      }
      @media (min-width: 768px) {
        .container {
          max-width: var(--container-md);
        }
      }
      @media (min-width: 1024px) {
        .container {
          max-width: var(--container-lg);
        }
      }
      @media (min-width: 1280px) {
        .container {
          max-width: var(--container-xl);
        }
      }

      /* Utility classes */
      .flex {
        display: flex;
      }
      .flex-col {
        flex-direction: column;
      }
      .items-center {
        align-items: center;
      }
      .justify-center {
        justify-content: center;
      }
      .justify-between {
        justify-content: space-between;
      }
      .gap-4 {
        gap: var(--space-4);
      }
      .gap-8 {
        gap: var(--space-8);
      }
      .gap-16 {
        gap: var(--space-16);
      }

      .m-0 {
        margin: 0;
      }
      .mt-8 {
        margin-top: var(--space-8);
      }
      .mb-8 {
        margin-bottom: var(--space-8);
      }
      .mx-8 {
        margin-left: var(--space-8);
        margin-right: var(--space-8);
      }
      .my-8 {
        margin-top: var(--space-8);
        margin-bottom: var(--space-8);
      }

      .p-0 {
        padding: 0;
      }
      .py-8 {
        padding-top: var(--space-8);
        padding-bottom: var(--space-8);
      }
      .px-8 {
        padding-left: var(--space-8);
        padding-right: var(--space-8);
      }
      .py-16 {
        padding-top: var(--space-16);
        padding-bottom: var(--space-16);
      }
      .px-16 {
        padding-left: var(--space-16);
        padding-right: var(--space-16);
      }

      .block {
        display: block;
      }
      .hidden {
        display: none;
      }

      /* Accessibility */
      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border-width: 0;
      }

      :focus-visible {
        outline: var(--focus-outline);
        outline-offset: 2px;
      }

      /* Dark mode specifics */
      [data-color-scheme="dark"] .btn--outline {
        border: 1px solid var(--color-border-secondary);
      }

      @font-face {
        font-family: 'FKGroteskNeue';
        src: url('https://r2cdn.perplexity.ai/fonts/FKGroteskNeue.woff2')
          format('woff2');
      }

      /* END PERPLEXITY DESIGN SYSTEM */
      
      /* --- START APP-SPECIFIC STYLES --- */
      
      /* Container layout */
      .container {
        width: 100%;
        margin-right: auto;
        margin-left: auto;
        padding-right: var(--space-16);
        padding-left: var(--space-16);
        max-width: var(--container-xl);
      }

      /* Header */
      .header {
        text-align: center;
        margin-bottom: var(--space-32);
        padding: var(--space-32) 0;
      }

      .header h1 {
        margin-bottom: var(--space-12);
      }

      .header p {
        color: var(--color-text-secondary);
        font-size: var(--font-size-lg);
      }

      /* Process Input Section */
      .process-form {
        margin-bottom: var(--space-24);
      }

      .form-row {
        display: flex;
        gap: var(--space-16);
        align-items: end;
        flex-wrap: wrap;
      }

      .form-row .form-group {
        flex: 1;
        min-width: 120px;
      }

      .preset-buttons {
        display: flex;
        gap: var(--space-8);
        flex-wrap: wrap;
      }

      /* Process Table */
      .processes-table-container {
        overflow-x: auto;
      }

      .processes-table {
        width: 100%;
        border-collapse: collapse;
        font-size: var(--font-size-sm);
      }

      .processes-table th,
      .processes-table td {
        padding: var(--space-8) var(--space-12);
        text-align: left;
        border-bottom: 1px solid var(--color-border);
      }

      .processes-table th {
        background-color: var(--color-secondary);
        font-weight: var(--font-weight-semibold);
      }

      .processes-table tr:hover {
        background-color: var(--color-bg-1);
      }

      /* Algorithm Section */
      .algorithm-controls {
        display: grid;
        gap: var(--space-16);
      }

      .algorithm-description {
        padding: var(--space-12);
        background-color: var(--color-bg-2);
        border-radius: var(--radius-base);
        border-left: 4px solid var(--color-primary);
      }

      .algorithm-description p {
        margin: 0;
        font-size: var(--font-size-sm);
        color: var(--color-text-secondary);
      }

      .action-buttons {
        display: flex;
        gap: var(--space-12);
        flex-wrap: wrap;
      }

      /* Results Section */
      .results-section {
        margin-top: var(--space-32);
      }

      /* Gantt Chart */
      .gantt-container {
        overflow-x: auto;
        padding: var(--space-16) 0;
      }

      #ganttChart {
        min-height: 100px;
        background-color: var(--color-bg-1);
        border-radius: var(--radius-base);
        padding: var(--space-16);
        overflow: hidden;
        position: relative;
      }

      /* Metrics Section */
      .metrics-tables {
        display: grid;
        gap: var(--space-24);
      }

      .table-container {
        overflow-x: auto;
      }

      .metrics-table {
        width: 100%;
        border-collapse: collapse;
        font-size: var(--font-size-sm);
      }

      .metrics-table th,
      .metrics-table td {
        padding: var(--space-8) var(--space-12);
        text-align: center;
        border-bottom: 1px solid var(--color-border);
      }

      .metrics-table th {
        background-color: var(--color-secondary);
        font-weight: var(--font-weight-semibold);
      }

      /* Summary Metrics */
      .summary-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: var(--space-16);
      }

      .summary-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: var(--space-12);
        background-color: var(--color-bg-3);
        border-radius: var(--radius-base);
        border-left: 4px solid var(--color-success);
      }

      .summary-label {
        font-size: var(--font-size-sm);
        color: var(--color-text-secondary);
      }

      .summary-value {
        font-size: var(--font-size-lg);
        font-weight: var(--font-weight-bold);
        color: var(--color-text);
      }

      /* Comparison Section */
      .comparison-section {
        margin-top: var(--space-32);
      }

      .comparison-table {
        width: 100%;
        border-collapse: collapse;
        font-size: var(--font-size-sm);
      }

      .comparison-table th,
      .comparison-table td {
        padding: var(--space-8) var(--space-12);
        text-align: center;
        border-bottom: 1px solid var(--color-border);
      }

      .comparison-table th {
        background-color: var(--color-secondary);
        font-weight: var(--font-weight-semibold);
      }

      .comparison-table .best-metric {
        background-color: var(--color-bg-3);
        font-weight: var(--font-weight-bold);
        color: var(--color-success);
      }

      .comparison-charts {
        margin-top: var(--space-24);
        display: flex;
        justify-content: center;
      }

      #comparisonChart {
        max-width: 100%;
        height: auto;
      }

      /* Help text */
      .help-text {
        font-size: var(--font-size-xs);
        color: var(--color-text-secondary);
        font-weight: var(--font-weight-normal);
      }

      /* Process color indicators */
      .process-color {
        display: inline-block;
        width: 16px;
        height: 16px;
        border-radius: var(--radius-sm);
        margin-right: var(--space-8);
        vertical-align: middle;
      }

      /* Responsive Design */
      @media (max-width: 768px) {
        .form-row {
          flex-direction: column;
          align-items: stretch;
        }
        
        .form-row .form-group {
          min-width: auto;
          margin-bottom: var(--space-8);
        }
        
        .form-row .form-group:last-child {
            margin-bottom: 0;
        }
        
        .form-row .btn {
            width: 100%;
        }
        
        .action-buttons {
          flex-direction: column;
        }
        
        .action-buttons .btn {
            width: 100%;
        }
        
        .preset-buttons {
          flex-direction: column;
          align-items: stretch !important;
        }
        
        .preset-buttons .btn {
            width: 100%;
        }
        
        .card__header {
          flex-direction: column;
          align-items: stretch;
        }
      }

      /* Gantt Chart Styles */
      .gantt-timeline {
        display: flex;
        flex-direction: column;
        gap: var(--space-8);
      }

      .gantt-header {
        display: flex;
        align-items: center;
        margin-bottom: var(--space-16);
      }

      .gantt-processes {
        display: flex;
        flex-direction: column;
        gap: var(--space-4);
      }

      .gantt-process-row {
        display: flex;
        align-items: center;
        min-height: 40px;
      }

      .gantt-process-label {
        width: 60px;
        font-size: var(--font-size-sm);
        font-weight: var(--font-weight-medium);
        text-align: center;
        flex-shrink: 0;
      }

      .gantt-timeline-bar {
        flex: 1;
        height: 32px;
        display: flex;
        position: relative;
        background-color: var(--color-bg-1);
        border-radius: var(--radius-sm);
        min-width: 500px; /* Ensure timeline has min-width for overflow */
      }

      .gantt-block {
        height: 100%;
        position: absolute;
        border-radius: var(--radius-sm);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: var(--font-size-xs);
        font-weight: var(--font-weight-medium);
        color: white;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        cursor: pointer;
        transition: opacity var(--duration-fast);
        border: 1px solid rgba(0, 0, 0, 0.1);
        overflow: hidden;
        white-space: nowrap;
      }

      .gantt-block:hover {
        opacity: 0.8;
      }

      .gantt-time-labels {
        display: flex;
        margin-top: var(--space-8);
        padding-left: 60px; /* Match label width */
        min-width: 500px; /* Match timeline bar min-width */
      }

      .gantt-time-label {
        font-size: var(--font-size-xs);
        color: var(--color-text-secondary);
        text-align: left;
        border-left: 1px solid var(--color-border);
        padding-left: var(--space-4);
        flex-shrink: 0;
        display: flex;
        align-items: flex-start;
      }
      
      .gantt-time-label:first-child {
          border-left: none;
      }

      .gantt-legend {
        display: flex;
        flex-wrap: wrap;
        gap: var(--space-16);
        margin-top: var(--space-16);
        padding-top: var(--space-16);
        border-top: 1px solid var(--color-border);
      }

      .gantt-legend-item {
        display: flex;
        align-items: center;
        gap: var(--space-8);
      }

      .gantt-legend-color {
        width: 16px;
        height: 16px;
        border-radius: var(--radius-sm);
        border: 1px solid rgba(0, 0, 0, 0.1);
      }

      .gantt-legend-label {
        font-size: var(--font-size-sm);
        color: var(--color-text-secondary);
      }
      
      /* --- NEW LLM/ML STYLES --- */
      
      .llm-smart-preset {
          margin-top: var(--space-24);
          border-top: 1px solid var(--color-card-border-inner);
          padding-top: var(--space-24);
      }
      
      .llm-smart-preset h3 {
          font-size: var(--font-size-xl);
          margin-bottom: var(--space-12);
          display: flex;
          align-items: center;
          gap: var(--space-8);
      }
      
      .llm-smart-preset p {
          color: var(--color-text-secondary);
          font-size: var(--font-size-sm);
          margin-bottom: var(--space-12);
      }
      
      #llmAnalysisResult {
          font-size: var(--font-size-md);
          line-height: var(--line-height-normal);
      }
      
      .spinner {
          border: 4px solid var(--color-border);
          border-top: 4px solid var(--color-primary);
          border-radius: 50%;
          width: 40px;
          height: 40px;
          animation: spin 1s linear infinite;
          display: inline-block;
      }
      
      .btn .spinner {
          width: 20px;
          height: 20px;
          border-width: 2px;
          margin-right: var(--space-8);
      }
      
      @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
      }

    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>ML/LLM CPU Scheduling Simulator</h1>
            <p>Compare scheduling algorithms with interactive charts, metrics, and AI-powered analysis</p>
        </header>

        <main class="main-content">
            <!-- Process Input Section -->
            <section class="card process-input-section">
                <div class="card__header">
                    <h2>Process Configuration</h2>
                    <div class="preset-buttons">
                        <button class="btn btn--secondary btn--sm" onclick="loadPreset('basic')">
                            Load Basic Example
                        </button>
                        <button class="btn btn--outline btn--sm" onclick="clearAllProcesses()">
                            Clear All
                        </button>
                    </div>
                </div>
                <div class="card__body">
                    <div class="process-form">
                        <div class="form-row">
                            <div class="form-group">
                                <label class="form-label">Process ID</label>
                                <input type="text" id="processId" class="form-control" readonly>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Arrival Time</label>
                                <input type="number" id="arrivalTime" class="form-control" min="0" placeholder="0">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Burst Time</label>
                                <input type="number" id="burstTime" class="form-control" min="1" placeholder="1">
                            </div>
                            <div class="form-group priority-group" style="display: none;">
                                <label class="form-label">Priority <span class="help-text">(lower = higher)</span></label>
                                <input type="number" id="priority" class="form-control" min="1" placeholder="1">
                            </div>
                            <div class="form-group">
                                <button class="btn btn--primary" onclick="addProcess()">Add Process</button>
                            </div>
                        </div>
                    </div>

                    <div class="processes-table-container">
                        <table class="processes-table">
                            <thead>
                                <tr>
                                    <th>Process ID</th>
                                    <th>Arrival Time</th>
                                    <th>Burst Time</th>
                                    <th class="priority-column" style="display: none;">Priority</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="processesTableBody">
                                <!-- Process rows will be added here -->
                            </tbody>
                        </table>
                    </div>
                    
                    <!-- 
                      NEW LLM Smart Preset Section
                    -->
                    <div class="llm-smart-preset">
                        <h3>
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z"/><path d="M5 3v4"/><path d="M19 17v4"/><path d="M3 5h4"/><path d="M17 19h4"/></svg>
                            Smart Process Generation
                        </h3>
                        <p>
                            Describe the type of workload you want to simulate (e.g., "5 processes, one long-running, others short")
                        </p>
                        <div class="form-group">
                            <label class="form-label" for="llmPresetPrompt">Workload Description:</label>
                            <textarea id="llmPresetPrompt" class="form-control" rows="2" placeholder="e.g., 'a 4-process workload with mixed arrival times and one high-priority job'"></textarea>
                        </div>
                        <button class="btn btn--secondary" id="llmPresetButton" onclick="getLLMSmartPreset()">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;"><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z"/><path d="M5 3v4"/><path d="M19 17v4"/><path d="M3 5h4"/><path d="M17 19h4"/></svg>
                            Generate Processes
                        </button>
                    </div>
                </div>
            </section>

            <!-- Algorithm Selection Section -->
            <section class="card algorithm-section">
                <div class="card__header">
                    <h2>Algorithm Configuration</h2>
                </div>
                <div class="card__body">
                    <div class="algorithm-controls">
                        <div class="form-group">
                            <label class="form-label">Select Scheduling Algorithm</label>
                            <select id="algorithmSelect" class="form-control" onchange="onAlgorithmChange()">
                                <option value="fcfs">First Come First Served (FCFS)</option>
                                <option value="sjf">Shortest Job First (SJF)</option>
                                <option value="srtf">Shortest Remaining Time First (SRTF)</option>
                                <option value="rr">Round Robin (RR)</option>
                                <option value="priority_np">Priority Scheduling (Non-preemptive)</option>
                                <option value="priority_p">Priority Scheduling (Preemptive)</option>
                            </select>
                        </div>
                        
                        <div class="form-group quantum-group" style="display: none;">
                            <label class="form-label">Time Quantum</label>
                            <input type="number" id="timeQuantum" class="form-control" min="1" value="2" placeholder="2">
                        </div>

                        <div class="algorithm-description">
                            <p id="algorithmDescription">Processes are executed in order of arrival time</p>
                        </div>

                        <div class="action-buttons">
                            <button class="btn btn--primary" onclick="runAlgorithm()">Run Algorithm</button>
                            <button class="btn btn--secondary" onclick="compareAllAlgorithms()">
                                Compare All Algorithms
                            </button>
                            <!-- NEW PREDICTIVE ML BUTTON -->
                            <button class="btn btn--outline" onclick="getLLMPrediction()">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;"><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z"/><path d="M5 3v4"/><path d="M19 17v4"/><path d="M3 5h4"/><path d="M17 19h4"/></svg>
                                Predict Best Algorithm
                            </button>
                        </div>
                    </div>
                </div>
            </section>

            <!-- 
              NEW LLM Analysis Section 
              This card will be shown when the user requests an analysis.
            -->
            <section class="card llm-analysis-section" id="llmAnalysisSection" style="display: none;">
                <div class="card__header">
                    <h2>
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: -4px; margin-right: 8px;"><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z"/><path d="M5 3v4"/><path d="M19 17v4"/><path d="M3 5h4"/><path d="M17 19h4"/></svg>
                        Smart Analysis
                    </h2>
                </div>
                <div class="card__body">
                    <div id="llmLoadingSpinner" style="display: none; text-align: center; padding: 20px;">
                        <div class="spinner"></div>
                        <p style="margin-top: 10px; color: var(--color-text-secondary); margin-bottom: 0;">Analyzing results with Gemini...</p>
                    </div>
                    <div id="llmAnalysisResult" style="display: none;">
                        <!-- Result will be populated here -->
                    </div>
                    <div id="llmAnalysisError" style="display: none;" class="status status--error">
                        <!-- Error message will be populated here -->
                    </div>
                </div>
            </section>

            <!-- Results Section -->
            <section class="results-section" style="display: none;">
                <!-- Gantt Chart -->
                <div class="card gantt-section">
                    <div class="card__header">
                        <h2>Gantt Chart</h2>
                    </div>
                    <div class="card__body">
                        <div class="gantt-container">
                            <div id="ganttChart"></div>
                        </div>
                    </div>
                </div>

                <!-- Performance Metrics -->
                <div class="card metrics-section">
                    <div class="card__header">
                        <h2>Performance Metrics</h2>
                    </div>
                    <div class="card__body">
                        <div class="metrics-tables">
                            <div class="process-metrics">
                                <h3>Per-Process Metrics</h3>
                                <div class="table-container">
                                    <table class="metrics-table">
                                        <thead>
                                            <tr>
                                                <th>Process</th>
                                                <th>Arrival</th>
                                                <th>Burst</th>
                                                <th>Completion</th>
                                                <th>Turnaround</th>
                                                <th>Waiting</th>
                                                <th>Response</th>
                                            </tr>
                                        </thead>
                                        <tbody id="metricsTableBody">
                                            <!-- Metrics rows will be added here -->
                                        </tbody>
                                    </table>
                                </div>
                            </div>

                            <div class="summary-metrics">
                                <h3>Summary Statistics</h3>
                                <div class="summary-grid">
                                    <div class="summary-item">
                                        <span class="summary-label">Average Waiting Time</span>
                                        <span class="summary-value" id="avgWaitingTime">-</span>
                                    </div>
                                    <div class="summary-item">
                                        <span class="summary-label">Average Turnaround Time</span>
                                        <span class="summary-value" id="avgTurnaroundTime">-</span>
                                    </div>
                                    <div class="summary-item">
                                        <span class="summary-label">Average Response Time</span>
                                        <span class="summary-value" id="avgResponseTime">-</span>
                                    </div>
                                    <div class="summary-item">
                                        <span class="summary-label">CPU Utilization</span>
                                        <span class="summary-value" id="cpuUtilization">-</span>
                                    </div>
                                    <div class="summary-item">
                                        <span class="summary-label">Throughput</span>
                                        <span class="summary-value" id="throughput">-</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- 
                          LLM Analysis Button 
                        -->
                        <div class="action-buttons" style="margin-top: var(--space-16);">
                            <button class="btn btn--secondary" onclick="getLLMAnalysis()">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;"><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z"/><path d="M5 3v4"/><path d="M19 17v4"/><path d="M3 5h4"/><path d="M17 19h4"/></svg>
                                Analyze these Results
                            </button>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Comparison Section -->
            <section class="comparison-section" style="display: none;">
                <div class="card">
                    <div class="card__header">
                        <h2>Algorithm Comparison</h2>
                    </div>
                    <div class="card__body">
                        <div class="comparison-tables">
                            <div class="table-container">
                                <table class="comparison-table">
                                    <thead>
                                        <tr>
                                            <th>Algorithm</th>
                                            <th>Avg Waiting Time</th>
                                            <th>Avg Turnaround Time</th>
                                            <th>Avg Response Time</th>
                                            <th>CPU Utilization</th>
                                            <th>Throughput</th>
                                        </tr>
                                    </thead>
                                    <tbody id="comparisonTableBody">
                                        <!-- Comparison rows will be added here -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        
                        <div class="comparison-charts">
                            <canvas id="comparisonChart" width="800" height="400"></canvas>
                        </div>
                        
                        <!-- 
                          LLM Recommendation Button 
                        -->
                        <div class="action-buttons" style="margin-top: var(--space-24); justify-content: center;">
                            <button class="btn btn--primary btn--lg" onclick="getLLMRecommendation()">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 10px;"><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z"/><path d="M5 3v4"/><path d="M19 17v4"/><path d="M3 5h4"/><path d="M17 19h4"/></svg>
                                Get Smart Recommendation
                            </button>
                        </div>
                        
                    </div>
                </div>
            </section>
        </main>
    </div>

    <!-- 
      Embedded JavaScript from app.js
    -->
    <script>
// CPU Scheduling Algorithm Simulator

// Global variables
let processes = [];
let processCounter = 1;
let currentResults = null;
let comparisonResults = {};

// --- REMOVED TTS State Management ---


// Process colors for visualization
const processColors = [
    '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
    '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9',
    '#F0B27A', '#76D7C4', '#F1948A', '#8E44AD', '#1ABC9C'
];

// Algorithm descriptions
const algorithmDescriptions = {
    'fcfs': 'Processes are executed in order of arrival time',
    'sjf': 'Process with shortest burst time is executed first',
    'srtf': 'Preemptive version of SJF - can interrupt running process',
    'rr': 'Each process gets equal time quantum in circular order',
    'priority_np': 'Process with highest priority executed first (lower number = higher priority)',
    'priority_p': 'Higher priority process can preempt currently running process (lower number = higher priority)'
};

// Sample data presets
const sampleData = {
    basic: [
        { id: 'P1', arrival: 0, burst: 6, priority: 2 },
        { id: 'P2', arrival: 2, burst: 8, priority: 1 },
        { id: 'P3', arrival: 4, burst: 7, priority: 3 },
        { id: 'P4', arrival: 6, burst: 3, priority: 2 }
    ]
};

// Initialize the application
document.addEventListener('DOMContentLoaded', function() {
    updateProcessId();
    onAlgorithmChange();
    // Load basic preset on start
    loadPreset('basic');
});

// Process management functions
function updateProcessId() {
    document.getElementById('processId').value = `P${processCounter}`;
}

function addProcess() {
    const arrivalTime = parseInt(document.getElementById('arrivalTime').value);
    const burstTime = parseInt(document.getElementById('burstTime').value);
    const priority = parseInt(document.getElementById('priority').value) || 1;
    
    // Validation
    if (isNaN(arrivalTime) || arrivalTime < 0) {
        alert('Please enter a valid arrival time (>= 0)');
        return;
    }
    
    if (isNaN(burstTime) || burstTime < 1) {
        alert('Please enter a valid burst time (> 0)');
        return;
    }
    
    const process = {
        id: `P${processCounter}`,
        arrival: arrivalTime,
        burst: burstTime,
        priority: priority,
        color: processColors[(processCounter - 1) % processColors.length]
    };
    
    processes.push(process);
    processCounter++;
    
    updateProcessTable();
    updateProcessId();
    clearInputs();
}

function removeProcess(index) {
    processes.splice(index, 1);
    // Re-assign colors
    processes.forEach((p, i) => {
        p.color = processColors[i % processColors.length];
    });
    updateProcessTable();
}

function clearInputs() {
    document.getElementById('arrivalTime').value = '';
    document.getElementById('burstTime').value = '';
    document.getElementById('priority').value = '';
}

function updateProcessTable() {
    const tbody = document.getElementById('processesTableBody');
    tbody.innerHTML = '';
    
    const showPriority = isPriorityNeeded();
    
    processes.forEach((process, index) => {
        const row = tbody.insertRow();
        row.innerHTML = `
            <td>
                <span class="process-color" style="background-color: ${process.color}"></span>
                ${process.id}
            </td>
            <td>${process.arrival}</td>
            <td>${process.burst}</td>
            <td class="priority-column" style="${showPriority ? '' : 'display: none;'}">${process.priority}</td>
            <td>
                <button class="btn btn--outline btn--sm" onclick="removeProcess(${index})">
                    Remove
                </button>
            </td>
        `;
    });
}

// Algorithm selection functions
function onAlgorithmChange() {
    const algorithm = document.getElementById('algorithmSelect').value;
    const quantumGroup = document.querySelector('.quantum-group');
    const priorityGroups = document.querySelectorAll('.priority-group');
    const priorityColumns = document.querySelectorAll('.priority-column');
    const description = document.getElementById('algorithmDescription');
    
    // Show/hide time quantum input
    if (algorithm === 'rr') {
        quantumGroup.style.display = 'block';
    } else {
        quantumGroup.style.display = 'none';
    }
    
    // Show/hide priority fields
    const needsPriority = algorithm.includes('priority');
    
    priorityGroups.forEach(el => {
        el.style.display = needsPriority ? 'block' : 'none';
    });
    
    priorityColumns.forEach(el => {
        el.style.display = needsPriority ? 'table-cell' : 'none';
    });
    
    // Update description
    description.textContent = algorithmDescriptions[algorithm];
    
    // Update table headers
    updateProcessTable();
}

function isPriorityNeeded() {
    const algorithm = document.getElementById('algorithmSelect').value;
    return algorithm.includes('priority');
}

// Preset data functions
function loadPreset(type) {
    processes = [];
    processCounter = 1;
    
    sampleData[type].forEach(p => {
        processes.push({
            ...p,
            color: processColors[(processCounter - 1) % processColors.length]
        });
        processCounter++;
    });
    
    updateProcessTable();
    updateProcessId();
}

function clearAllProcesses() {
    processes = [];
    processCounter = 1;
    updateProcessTable();
    updateProcessId();
    
    // Hide results
    document.querySelector('.results-section').style.display = 'none';
    document.querySelector('.comparison-section').style.display = 'none';
    document.getElementById('llmAnalysisSection').style.display = 'none';
}

// Scheduling algorithm implementations
function runFCFS(processes) {
    const result = {
        timeline: [],
        metrics: [],
        algorithm: 'FCFS'
    };
    
    const sortedProcesses = [...processes].map(p => ({...p})).sort((a, b) => a.arrival - b.arrival);
    let currentTime = 0;
    
    sortedProcesses.forEach(process => {
        const startTime = Math.max(currentTime, process.arrival);
        const completionTime = startTime + process.burst;
        
        result.timeline.push({
            processId: process.id,
            startTime: startTime,
            endTime: completionTime,
            color: process.color
        });
        
        result.metrics.push({
            processId: process.id,
            arrival: process.arrival,
            burst: process.burst,
            completion: completionTime,
            turnaround: completionTime - process.arrival,
            waiting: (completionTime - process.arrival) - process.burst,
            response: startTime - process.arrival
        });
        
        currentTime = completionTime;
    });
    
    return result;
}

function runSJF(processes) {
    const result = {
        timeline: [],
        metrics: [],
        algorithm: 'SJF'
    };
    
    const processList = processes.map(p => ({ ...p, completed: false }));
    let currentTime = 0;
    let completedCount = 0;
    
    while (completedCount < processList.length) {
        const availableProcesses = processList.filter(p => !p.completed && p.arrival <= currentTime);
        
        if (availableProcesses.length === 0) {
            // No process available, move time forward to the next arrival
            const nextArrivalTime = Math.min(...processList.filter(p => !p.completed).map(p => p.arrival));
            currentTime = nextArrivalTime;
            continue;
        }
        
        // Select process with shortest burst time
        const selectedProcess = availableProcesses.reduce((shortest, current) => 
            current.burst < shortest.burst ? current : shortest
        );
        
        const startTime = currentTime;
        const completionTime = startTime + selectedProcess.burst;
        
        result.timeline.push({
            processId: selectedProcess.id,
            startTime: startTime,
            endTime: completionTime,
            color: selectedProcess.color
        });
        
        result.metrics.push({
            processId: selectedProcess.id,
            arrival: selectedProcess.arrival,
            burst: selectedProcess.burst,
            completion: completionTime,
            turnaround: completionTime - selectedProcess.arrival,
            waiting: (completionTime - selectedProcess.arrival) - selectedProcess.burst,
            response: startTime - selectedProcess.arrival
        });
        
        selectedProcess.completed = true;
        completedCount++;
        currentTime = completionTime;
    }
    
    return result;
}

function runSRTF(processes) {
    const result = {
        timeline: [],
        metrics: [],
        algorithm: 'SRTF'
    };
    
    const processList = processes.map(p => ({ 
        ...p, 
        remainingTime: p.burst,
        firstStart: null
    }));
    
    let currentTime = 0;
    let completedCount = 0;
    
    while (completedCount < processList.length) {
        const availableProcesses = processList.filter(p => p.remainingTime > 0 && p.arrival <= currentTime);
        
        if (availableProcesses.length === 0) {
            // No process available, move time forward
            const nextArrivalTime = Math.min(...processList.filter(p => p.remainingTime > 0).map(p => p.arrival));
            currentTime = nextArrivalTime;
            continue;
        }
        
        // Select process with shortest remaining time
        const selectedProcess = availableProcesses.reduce((shortest, current) => 
            current.remainingTime < shortest.remainingTime ? current : shortest
        );
        
        if (selectedProcess.firstStart === null) {
            selectedProcess.firstStart = currentTime;
        }
        
        const startTime = currentTime;
        currentTime++;
        selectedProcess.remainingTime--;
        
        // Add to timeline (merge consecutive blocks of same process)
        const lastBlock = result.timeline[result.timeline.length - 1];
        if (lastBlock && lastBlock.processId === selectedProcess.id && lastBlock.endTime === startTime) {
            lastBlock.endTime = currentTime;
        } else {
            result.timeline.push({
                processId: selectedProcess.id,
                startTime: startTime,
                endTime: currentTime,
                color: selectedProcess.color
            });
        }
        
        if (selectedProcess.remainingTime === 0) {
            completedCount++;
            result.metrics.push({
                processId: selectedProcess.id,
                arrival: selectedProcess.arrival,
                burst: selectedProcess.burst,
                completion: currentTime,
                turnaround: currentTime - selectedProcess.arrival,
                waiting: (currentTime - selectedProcess.arrival) - selectedProcess.burst,
                response: selectedProcess.firstStart - selectedProcess.arrival
            });
        }
    }
    
    return result;
}

function runRoundRobin(processes, quantum) {
    const result = {
        timeline: [],
        metrics: [],
        algorithm: `Round Robin (q=${quantum})`
    };
    
    const processList = processes.map(p => ({ 
        ...p, 
        remainingTime: p.burst,
        firstStart: null
    }));
    
    let currentTime = 0;
    const readyQueue = [];
    let processIndex = 0; // To track arrivals
    
    // Sort processes by arrival time to add them to queue correctly
    processList.sort((a, b) => a.arrival - b.arrival);
    
    while (processList.some(p => p.remainingTime > 0) || readyQueue.length > 0) {
        
        // Add newly arrived processes to ready queue
        while (processIndex < processList.length && processList[processIndex].arrival <= currentTime) {
            readyQueue.push(processList[processIndex]);
            processIndex++;
        }
        
        if (readyQueue.length === 0) {
            // No process in ready queue, move time forward
            if (processIndex < processList.length) {
                currentTime = processList[processIndex].arrival;
            } else {
                break; // All processes done
            }
            continue;
        }
        
        const currentProcess = readyQueue.shift();
        
        if (currentProcess.firstStart === null) {
            currentProcess.firstStart = currentTime;
        }
        
        const startTime = currentTime;
        const executionTime = Math.min(quantum, currentProcess.remainingTime);
        currentProcess.remainingTime -= executionTime;
        currentTime += executionTime;
        
        result.timeline.push({
            processId: currentProcess.id,
            startTime: startTime,
            endTime: currentTime,
            color: currentProcess.color
        });
        
        // Add newly arrived processes that came *during* this quantum
        while (processIndex < processList.length && processList[processIndex].arrival <= currentTime) {
            readyQueue.push(processList[processIndex]);
            processIndex++;
        }
        
        if (currentProcess.remainingTime > 0) {
            readyQueue.push(currentProcess); // Add back to end of queue
        } else {
            // Process finished
            result.metrics.push({
                processId: currentProcess.id,
                arrival: currentProcess.arrival,
                burst: currentProcess.burst,
                completion: currentTime,
                turnaround: currentTime - currentProcess.arrival,
                waiting: (currentTime - currentProcess.arrival) - currentProcess.burst,
                response: currentProcess.firstStart - currentProcess.arrival
            });
        }
    }
    
    return result;
}


function runPriorityNonPreemptive(processes) {
    const result = {
        timeline: [],
        metrics: [],
        algorithm: 'Priority (Non-preemptive)'
    };
    
    const processList = processes.map(p => ({ ...p, completed: false }));
    let currentTime = 0;
    let completedCount = 0;
    
    while (completedCount < processList.length) {
        const availableProcesses = processList.filter(p => !p.completed && p.arrival <= currentTime);
        
        if (availableProcesses.length === 0) {
            // No process available, move time forward
            const nextArrivalTime = Math.min(...processList.filter(p => !p.completed).map(p => p.arrival));
            currentTime = nextArrivalTime;
            continue;
        }
        
        // Select process with highest priority (lower number = higher priority)
        const selectedProcess = availableProcesses.reduce((highest, current) => 
            current.priority < highest.priority ? current : highest
        );
        
        const startTime = currentTime;
        const completionTime = startTime + selectedProcess.burst;
        
        result.timeline.push({
            processId: selectedProcess.id,
            startTime: startTime,
            endTime: completionTime,
            color: selectedProcess.color
        });
        
        result.metrics.push({
            processId: selectedProcess.id,
            arrival: selectedProcess.arrival,
            burst: selectedProcess.burst,
            completion: completionTime,
            turnaround: completionTime - selectedProcess.arrival,
            waiting: (completionTime - selectedProcess.arrival) - selectedProcess.burst,
            response: startTime - selectedProcess.arrival
        });
        
        selectedProcess.completed = true;
        completedCount++;
        currentTime = completionTime;
    }
    
    return result;
}

function runPriorityPreemptive(processes) {
    const result = {
        timeline: [],
        metrics: [],
        algorithm: 'Priority (Preemptive)'
    };
    
    const processList = processes.map(p => ({ 
        ...p, 
        remainingTime: p.burst,
        firstStart: null
    }));
    
    let currentTime = 0;
    let completedCount = 0;
    
    while (completedCount < processList.length) {
        const availableProcesses = processList.filter(p => p.remainingTime > 0 && p.arrival <= currentTime);
        
        if (availableProcesses.length === 0) {
            // No process available, move time forward
            const nextArrivalTime = Math.min(...processList.filter(p => p.remainingTime > 0).map(p => p.arrival));
            currentTime = nextArrivalTime;
            continue;
        }
        
        // Select process with highest priority (lower number = higher priority)
        const selectedProcess = availableProcesses.reduce((highest, current) => 
            current.priority < highest.priority ? current : highest
        );
        
        if (selectedProcess.firstStart === null) {
            selectedProcess.firstStart = currentTime;
        }
        
        const startTime = currentTime;
        currentTime++;
        selectedProcess.remainingTime--;
        
        // Add to timeline (merge consecutive blocks of same process)
        const lastBlock = result.timeline[result.timeline.length - 1];
        if (lastBlock && lastBlock.processId === selectedProcess.id && lastBlock.endTime === startTime) {
            lastBlock.endTime = currentTime;
        } else {
            result.timeline.push({
                processId: selectedProcess.id,
                startTime: startTime,
                endTime: currentTime,
                color: selectedProcess.color
            });
        }
        
        if (selectedProcess.remainingTime === 0) {
            completedCount++;
            result.metrics.push({
                processId: selectedProcess.id,
                arrival: selectedProcess.arrival,
                burst: selectedProcess.burst,
                completion: currentTime,
                turnaround: currentTime - selectedProcess.arrival,
                waiting: (currentTime - selectedProcess.arrival) - selectedProcess.burst,
                response: selectedProcess.firstStart - selectedProcess.arrival
            });
        }
    }
    
    return result;
}

// Main execution functions
function runAlgorithm() {
    if (processes.length === 0) {
        alert('Please add at least one process');
        return;
    }
    
    // Clear any previous LLM results
    document.getElementById('llmAnalysisSection').style.display = 'none';

    const algorithm = document.getElementById('algorithmSelect').value;
    const timeQuantum = parseInt(document.getElementById('timeQuantum').value) || 2;
    
    // Create a deep copy of processes for the simulation
    const processesCopy = processes.map(p => ({ ...p }));
    let result;
    
    switch (algorithm) {
        case 'fcfs':
            result = runFCFS(processesCopy);
            break;
        case 'sjf':
            result = runSJF(processesCopy);
            break;
        case 'srtf':
            result = runSRTF(processesCopy);
            break;
        case 'rr':
            result = runRoundRobin(processesCopy, timeQuantum);
            break;
        case 'priority_np':
            result = runPriorityNonPreemptive(processesCopy);
            break;
        case 'priority_p':
            result = runPriorityPreemptive(processesCopy);
            break;
        default:
            alert('Invalid algorithm selected');
            return;
    }
    
    currentResults = result;
    displayResults(result);
    
    // Show results section
    document.querySelector('.results-section').style.display = 'block';
    document.querySelector('.comparison-section').style.display = 'none';
}

function compareAllAlgorithms() {
    if (processes.length === 0) {
        alert('Please add at least one process');
        return;
    }
    
    // Clear any previous LLM results
    document.getElementById('llmAnalysisSection').style.display = 'none';
    
    const processesCopy = processes.map(p => ({ ...p }));
    const timeQuantum = parseInt(document.getElementById('timeQuantum').value) || 2;
    
    const algorithms = {
        'FCFS': () => runFCFS(processesCopy.map(p => ({...p}))),
        'SJF': () => runSJF(processesCopy.map(p => ({...p}))),
        'SRTF': () => runSRTF(processesCopy.map(p => ({...p}))),
        [`Round Robin (q=${timeQuantum})`]: () => runRoundRobin(processesCopy.map(p => ({...p})), timeQuantum),
        'Priority (NP)': () => runPriorityNonPreemptive(processesCopy.map(p => ({...p}))),
        'Priority (P)': () => runPriorityPreemptive(processesCopy.map(p => ({...p})))
    };
    
    comparisonResults = {};
    
    Object.entries(algorithms).forEach(([name, func]) => {
        try {
            comparisonResults[name] = func();
        } catch (error) {
            console.error(`Error running ${name}:`, error);
        }
    });
    
    displayComparison();
    
    // Show comparison section
    document.querySelector('.results-section').style.display = 'none';
    document.querySelector('.comparison-section').style.display = 'block';
}

// Display functions
function displayResults(result) {
    // Sort metrics by process ID for consistent table display
    result.metrics.sort((a, b) => a.processId.localeCompare(b.processId, undefined, {numeric: true}));
    
    displayGanttChart(result);
    displayMetrics(result);
}

function displayGanttChart(result) {
    const container = document.getElementById('ganttChart');
    container.innerHTML = '';
    
    if (!result.timeline || result.timeline.length === 0) {
        container.innerHTML = '<p>No timeline data available</p>';
        return;
    }
    
    const maxTime = Math.max(1, ...result.timeline.map(block => block.endTime));
    
    // Create Gantt chart HTML
    const ganttHTML = `
        <div class="gantt-timeline">
            <div class="gantt-header">
                <h4>Process Execution Timeline - ${result.algorithm}</h4>
            </div>
            <div class="gantt-processes">
                <div class="gantt-process-row">
                    <div class="gantt-process-label">CPU</div>
                    <div class="gantt-timeline-bar">
                        ${result.timeline.map(block => {
                            const width = ((block.endTime - block.startTime) / maxTime) * 100;
                            const left = (block.startTime / maxTime) * 100;
                            return `
                                <div class="gantt-block" 
                                     style="width: ${width}%; left: ${left}%; background-color: ${block.color};"
                                     title="${block.processId}: ${block.startTime}-${block.endTime}">
                                    ${block.processId}
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            </div>
            <div class="gantt-time-labels">
                ${Array.from({ length: Math.ceil(maxTime) + 1 }, (_, i) => i).map(time => `
                    <div class="gantt-time-label" style="width: ${100 / maxTime}%">
                        ${time}
                    </div>
                `).join('')}
            </div>
            <div class="gantt-legend">
                ${processes.map(process => `
                    <div class="gantt-legend-item">
                        <div class="gantt-legend-color" style="background-color: ${process.color}"></div>
                        <span class="gantt-legend-label">${process.id}</span>
                    </div>
                `).join('')}
            </div>
        </div>
    `;
    
    container.innerHTML = ganttHTML;
}


function displayMetrics(result) {
    const tbody = document.getElementById('metricsTableBody');
    tbody.innerHTML = '';
    
    let totalWaiting = 0;
    let totalTurnaround = 0;
    let totalResponse = 0;
    let totalBurst = 0;
    
    result.metrics.forEach(metric => {
        const row = tbody.insertRow();
        row.innerHTML = `
            <td>${metric.processId}</td>
            <td>${metric.arrival}</td>
            <td>${metric.burst}</td>
            <td>${metric.completion}</td>
            <td>${metric.turnaround}</td>
            <td>${metric.waiting}</td>
            <td>${metric.response}</td>
        `;
        
        totalWaiting += metric.waiting;
        totalTurnaround += metric.turnaround;
        totalResponse += metric.response;
        totalBurst += metric.burst;
    });
    
    const processCount = result.metrics.length;
    const totalTime = Math.max(1, ...result.metrics.map(m => m.completion));
    
    // Update summary statistics
    document.getElementById('avgWaitingTime').textContent = (totalWaiting / processCount).toFixed(2);
    document.getElementById('avgTurnaroundTime').textContent = (totalTurnaround / processCount).toFixed(2);
    document.getElementById('avgResponseTime').textContent = (totalResponse / processCount).toFixed(2);
    document.getElementById('cpuUtilization').textContent = ((totalBurst / totalTime) * 100).toFixed(2) + '%';
    document.getElementById('throughput').textContent = (processCount / totalTime).toFixed(2);
}

function displayComparison() {
    const tbody = document.getElementById('comparisonTableBody');
    tbody.innerHTML = '';
    
    const comparisonData = [];
    
    Object.entries(comparisonResults).forEach(([algorithmName, result]) => {
        if (!result.metrics || result.metrics.length === 0) {
            return;
        }
        
        const processCount = result.metrics.length;
        const totalBurst = result.metrics.reduce((sum, m) => sum + m.burst, 0);
        const totalWaiting = result.metrics.reduce((sum, m) => sum + m.waiting, 0);
        const totalTurnaround = result.metrics.reduce((sum, m) => sum + m.turnaround, 0);
        const totalResponse = result.metrics.reduce((sum, m) => sum + m.response, 0);
        const totalTime = Math.max(1, ...result.metrics.map(m => m.completion));
        
        const data = {
            algorithm: algorithmName,
            avgWaiting: totalWaiting / processCount,
            avgTurnaround: totalTurnaround / processCount,
            avgResponse: totalResponse / processCount,
            cpuUtilization: (totalBurst / totalTime) * 100,
            throughput: processCount / totalTime
        };
        
        comparisonData.push(data);
        
        const row = tbody.insertRow();
        row.innerHTML = `
            <td><strong>${data.algorithm}</strong></td>
            <td>${data.avgWaiting.toFixed(2)}</td>
            <td>${data.avgTurnaround.toFixed(2)}</td>
            <td>${data.avgResponse.toFixed(2)}</td>
            <td>${data.cpuUtilization.toFixed(2)}%</td>
            <td>${data.throughput.toFixed(2)}</td>
        `;
    });
    
    // Highlight best performers
    highlightBestMetrics(comparisonData);
    
    // Draw comparison chart (if Chart.js was loaded)
    if (typeof Chart !== 'undefined') {
        drawComparisonChart(comparisonData);
    } else {
        console.warn('Chart.js is not loaded. Skipping chart drawing.');
        const canvas = document.getElementById('comparisonChart');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'var(--color-text-secondary)';
        ctx.font = '14px var(--font-family-base)';
        ctx.textAlign = 'center';
        ctx.fillText('Chart.js library not found. Cannot display chart.', canvas.width / 2, 50);
    }
}

function highlightBestMetrics(data) {
    if (data.length === 0) return;
    
    const bestWaiting = Math.min(...data.map(d => d.avgWaiting));
    const bestTurnaround = Math.min(...data.map(d => d.avgTurnaround));
    const bestResponse = Math.min(...data.map(d => d.avgResponse));
    const bestUtilization = Math.max(...data.map(d => d.cpuUtilization));
    const bestThroughput = Math.max(...data.map(d => d.throughput));
    
    const rows = document.querySelectorAll('#comparisonTableBody tr');
    
    data.forEach((item, index) => {
        if (!rows[index]) return; // Guard clause
        const cells = rows[index].cells;
        
        // Clear previous bests
        Array.from(cells).forEach(cell => cell.classList.remove('best-metric'));

        if (item.avgWaiting === bestWaiting) {
            cells[1].classList.add('best-metric');
        }
        if (item.avgTurnaround === bestTurnaround) {
            cells[2].classList.add('best-metric');
        }
        if (item.avgResponse === bestResponse) {
            cells[3].classList.add('best-metric');
        }
        if (item.cpuUtilization === bestUtilization) {
            cells[4].classList.add('best-metric');
        }
        if (item.throughput === bestThroughput) {
            cells[5].classList.add('best-metric');
        }
    });
}

function drawComparisonChart(data) {
    // This function was in the original app.js but depended on Chart.js,
    // which was not included in the original HTML.
    // I am leaving this stub here. If you load Chart.js, it will work.
    
    const canvas = document.getElementById('comparisonChart');
    const ctx = canvas.getContext('2d');
    
    // Check if Chart.js is loaded
    if (typeof Chart === 'undefined') {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'var(--color-text-secondary)';
        ctx.font = '14px var(--font-family-base)';
        ctx.textAlign = 'center';
        ctx.fillText('To see the chart, please load the Chart.js library.', canvas.width / 2, 50);
        return;
    }

    // Destroy existing chart instance if it exists
    if (window.myComparisonChart) {
        window.myComparisonChart.destroy();
    }

    const labels = data.map(d => d.algorithm);
    const avgWaitingData = data.map(d => d.avgWaiting);
    const avgTurnaroundData = data.map(d => d.avgTurnaround);
    const avgResponseData = data.map(d => d.avgResponse);

    window.myComparisonChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'Avg Waiting Time',
                    data: avgWaitingData,
                    backgroundColor: 'rgba(255, 107, 107, 0.7)', // --color-bg-4
                    borderColor: 'rgba(255, 107, 107, 1)',
                    borderWidth: 1
                },
                {
                    label: 'Avg Turnaround Time',
                    data: avgTurnaroundData,
                    backgroundColor: 'rgba(78, 205, 196, 0.7)', // --color-bg-3
                    borderColor: 'rgba(78, 205, 196, 1)',
                    borderWidth: 1
                },
                {
                    label: 'Avg Response Time',
                    data: avgResponseData,
                    backgroundColor: 'rgba(69, 183, 209, 0.7)', // --color-bg-8
                    borderColor: 'rgba(69, 183, 209, 1)',
                    borderWidth: 1
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        color: 'var(--color-text-secondary)'
                    },
                    grid: {
                        color: 'var(--color-border)'
                    }
                },
                x: {
                    ticks: {
                        color: 'var(--color-text-secondary)'
                    },
                    grid: {
                        display: false
                    }
                }
            },
            plugins: {
                legend: {
                    labels: {
                        color: 'var(--color-text)'
                    }
                }
            }
        }
    });
}


// --- NEW LLM/ML EMPOWERMENT FUNCTIONS ---

/**
 * Safely stringifies an object, handling potential circular references
 * or large numbers.
 * @param {object} obj The object to stringify.
 * @returns {string} A JSON string.
 */
function safeJsonStringify(obj) {
    try {
        // Simple stringify for this app's data structure
        return JSON.stringify(obj, (key, value) =>
            typeof value === 'number' && !isFinite(value) ? 'Infinity' : value
        , 2); // Pretty-print with 2 spaces
    } catch (e) {
        console.error("Error stringifying JSON:", e);
        return "{}";
    }
}

/**
 * Controls the display of the LLM Analysis card.
 * @param {'loading' | 'success' | 'error'} state The state to display.
 * @param {string} [content=''] The HTML content or error message.
 */
function showLLMAnalysis(state, content = '') {
    const section = document.getElementById('llmAnalysisSection');
    const loadingSpinner = document.getElementById('llmLoadingSpinner');
    const resultDisplay = document.getElementById('llmAnalysisResult');
    const errorDisplay = document.getElementById('llmAnalysisError');
    
    section.style.display = 'block';
    
    // Reset states
    loadingSpinner.style.display = 'none';
    resultDisplay.style.display = 'none';
    errorDisplay.style.display = 'none';
    
    
    if (state === 'loading') {
        loadingSpinner.style.display = 'block';
    } else if (state === 'success') {
        // Basic Markdown-to-HTML conversion
        let htmlContent = content
            .replace(/^### (.*$)/gim, '<h4>$1</h4>') // h3 -> h4
            .replace(/^## (.*$)/gim, '<h3>$1</h3>') // h2 -> h3
            .replace(/^\* (.*$)/gim, '<ul><li>$1</li></ul>') // unordered lists
            .replace(/^1\. (.*$)/gim, '<ol><li>$1</li></ol>') // ordered lists
            .replace(/<\/ul>\s*<ul>/gim, '') // merge adjacent <ul>
            .replace(/<\/ol>\s*<ol>/gim, '') // merge adjacent <ol>
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') // bold
            .replace(/\*(.*?)\*/g, '<em>$1</em>') // italic
            .replace(/`([^`]+)`/g, '<code>$1</code>') // inline code
            .replace(/\n/g, '<br>'); // newlines
            
        resultDisplay.innerHTML = htmlContent;
        resultDisplay.style.display = 'block';
        
        // --- REMOVED TTS PART ---
        
        // Scroll to the result
        section.scrollIntoView({ behavior: 'smooth', block: 'start' });
    } else if (state === 'error') {
        errorDisplay.textContent = content || 'An unknown error occurred.';
        errorDisplay.style.display = 'block';
        // Scroll to the result
        section.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
}

/**
 * Makes the API call to the Gemini model for text generation.
 * @param {string} systemPrompt The system-level instruction for the model.
 * @param {string} userPrompt The user's specific query.
 */
async function callGeminiAPI(systemPrompt, userPrompt) {
    showLLMAnalysis('loading');
    
    const apiKey = "AIzaSyCUTXFQzp-WLp2y-RqypZJEQIz1uiw_K0w"; // API key will be injected by the environment
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

    const payload = {
        contents: [{
            parts: [{ text: userPrompt }]
        }],
        systemInstruction: {
            parts: [{ text: systemPrompt }]
        },
    };

    // We'll use exponential backoff for retries
    let response;
    let retries = 0;
    const maxRetries = 3;
    let delay = 1000;

    while (retries < maxRetries) {
        try {
            response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (response.ok) {
                // Success, break the loop
                break;
            } else if (response.status === 429) {
                // Throttled, wait and retry
                console.warn(`API throttling. Retrying in ${delay}ms...`);
                await new Promise(resolve => setTimeout(resolve, delay));
                delay *= 2; // Exponential backoff
                retries++;
            } else {
                // Other API error
                throw new Error(`API Error: ${response.statusText} (Status: ${response.status})`);
            }
        } catch (error) {
            console.error("Fetch error:", error);
            // This might be a network error, retry
            if (retries >= maxRetries - 1) {
                 showLLMAnalysis('error', `Network Error: ${error.message}. Please check your connection.`);
                 return;
            }
            await new Promise(resolve => setTimeout(resolve, delay));
            delay *= 2;
            retries++;
        }
    }


    if (!response || !response.ok) {
        showLLMAnalysis('error', `Failed to get a response from the API after ${maxRetries} retries.`);
        return;
    }

    try {
        const result = await response.json();
        const candidate = result.candidates?.[0];

        if (candidate && candidate.content?.parts?.[0]?.text) {
            const text = candidate.content.parts[0].text;
            showLLMAnalysis('success', text);
        } else {
            console.warn("API response was successful but missing expected content:", result);
            if (result.promptFeedback) {
                throw new Error(`API call blocked: ${result.promptFeedback.blockReason}`);
            }
            throw new Error("Received an empty or invalid response from the API.");
        }
    } catch (error) {
        console.error("Error parsing API response:", error);
        showLLMAnalysis('error', `Error: ${error.message}.`);
    }
}

/**
 * Called when the "Analyze these Results" button is clicked.
 * Prepares and sends a prompt for a single algorithm's results.
 */
function getLLMAnalysis() {
    if (!currentResults) {
        alert("Please run an algorithm first.");
        return;
    }
    
    const systemPrompt = "You are a helpful computer science expert, acting as a teaching assistant for an operating systems class. Your goal is to explain CPU scheduling concepts clearly and concisely based on the data provided. Do not use complex jargon. Format your answer in simple Markdown.";
    
    const processesData = safeJsonStringify(processes);
    const resultsData = safeJsonStringify({
        algorithm: currentResults.algorithm,
        metrics: currentResults.metrics
        // Timeline is omitted to keep the prompt smaller and focused
    });

    const userPrompt = `
I ran a simulation for the "${currentResults.algorithm}" CPU scheduling algorithm.
Here is the input (the processes):
${processesData}

Here are the resulting performance metrics:
${resultsData}

Please provide a concise analysis (max 2-3 paragraphs) explaining these results. 
Focus on *why* the results are what they are. For example:
1.  Briefly explain how the "${currentResults.algorithm}" algorithm works (1-2 sentences).
2.  Based on the metrics (like waiting and response time), explain why this algorithm performed the way it did for this *specific* set of processes.
3.  Give one key takeaway or observation from this simulation.
`;

    callGeminiAPI(systemPrompt, userPrompt);
}

// --- REMOVED ALL TTS Helper Functions ---
// (resetTTSState, handleReadAloudClick, base64ToArrayBuffer, pcmToWav, callGeminiTTSAPI)


// --- NEW Smart Prediction Function ---

/**
 * Calls the Gemini API to predict the best algorithm based on inputs.
 */
function getLLMPrediction() {
    if (processes.length === 0) {
        alert("Please add at least one process to get a prediction.");
        return;
    }

    const systemPrompt = "You are an expert operating systems analyst, acting as a predictive model. Your job is to analyze a set of input processes and *predict* which scheduling algorithm (FCFS, SJF, SRTF, Round Robin, Priority) would likely be most efficient (e.g., lowest average waiting time). Base your prediction on the characteristics of the workload. Format your answer in simple Markdown.";
    
    const processesData = safeJsonStringify(processes);

    const userPrompt = `
Here is my workload (my input processes):
${processesData}

Based *only* on these input processes, please provide a prediction:
1.  **Workload Analysis:** Briefly describe this workload (e.g., "This is a burst-heavy workload," "Processes arrive at staggered times," "There is a mix of long and short jobs," etc.).
2.  **Best Algorithm Prediction:** Which algorithm (e.g., SJF, SRTF, RR) do you *predict* will perform best for this specific workload, and *why*? (e.g., "I predict SRTF will be best because its preemptive nature can handle the short jobs that arrive while the long job is running.")
3.  **Worst Algorithm Prediction:** Which algorithm do you predict will perform the worst, and why?
`;

    callGeminiAPI(systemPrompt, userPrompt);
}


// --- NEW Smart Preset Function ---

/**
 * Calls the Gemini API to generate a set of processes from a natural language prompt.
 */
async function getLLMSmartPreset() {
    const button = document.getElementById('llmPresetButton');
    button.disabled = true;
    button.innerHTML = '<div class="spinner"></div> Generating...';

    // Get the user prompt from the textarea
    const promptTextarea = document.getElementById('llmPresetPrompt');
    const userPrompt = promptTextarea ? promptTextarea.value.trim() : '';
    
    if (!userPrompt) {
        alert('Please enter a workload description before generating processes.');
        button.disabled = false;
        button.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;"><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z"/><path d="M5 3v4"/><path d="M19 17v4"/><path d="M3 5h4"/><path d="M17 19h4"/></svg>Generate Processes';
        return;
    }

    const apiKey = "AIzaSyCUTXFQzp-WLp2y-RqypZJEQIz1uiw_K0w";
    // --- MODIFICATION: Use gemini-2.5-flash-preview-09-2025 for structured JSON generation ---
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

    // Define the JSON schema for the response
    const schema = {
        type: "ARRAY",
        items: {
            type: "OBJECT",
            properties: {
                "arrival": { "type": "NUMBER", "description": "Arrival time, >= 0" },
                "burst": { "type": "NUMBER", "description": "Burst time, >= 1" },
                "priority": { "type": "NUMBER", "description": "Priority, >= 1 (lower is higher)" }
            },
            required: ["arrival", "burst", "priority"]
        }
    };
    
    const systemPrompt = `You are a process generator for a CPU scheduling simulator. The user will describe a workload. You MUST return *only* a valid JSON array of process objects based on the description. Each object must have "arrival" (number, >= 0), "burst" (number, >= 1), and "priority" (number, >= 1). Adhere to the user's request (e.g., number of processes).`;

    const payload = {
        contents: [{ parts: [{ text: userPrompt }] }],
        systemInstruction: { parts: [{ text: systemPrompt }] },
        generationConfig: {
            responseMimeType: "application/json",
            responseSchema: schema
        }
    };

    try {
        let response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        
        if (!response.ok) {
            // --- MODIFICATION: Add better error logging ---
            let errorBody = "Could not parse error response.";
            try {
                errorBody = await response.json();
            } catch(e) {
                // Ignore if response isn't JSON
            }
            console.error("API Error Response:", errorBody);
            throw new Error(`API Error: ${response.statusText} (Status: ${response.status})`);
            // --- END MODIFICATION ---
        }

        const result = await response.json();
        const candidate = result.candidates?.[0];
        
        if (candidate && candidate.content?.parts?.[0]?.text) {
            const jsonText = candidate.content.parts[0].text;
            const generatedProcesses = JSON.parse(jsonText);
            
            // Validate and load the processes
            if (Array.isArray(generatedProcesses) && generatedProcesses.length > 0) {
                clearAllProcesses(); // Clear existing
                processes = []; // Reset global
                processCounter = 1; // Reset counter
                
                generatedProcesses.forEach(p => {
                    const newProcess = {
                        id: `P${processCounter}`,
                        arrival: Math.max(0, parseInt(p.arrival || 0)),
                        burst: Math.max(1, parseInt(p.burst || 1)),
                        priority: Math.max(1, parseInt(p.priority || 1)),
                        color: processColors[(processCounter - 1) % processColors.length]
                    };
                    processes.push(newProcess);
                    processCounter++;
                });
                
                updateProcessTable();
                updateProcessId();
                if (promptTextarea) promptTextarea.value = ''; // Clear prompt
            } else {
                throw new Error("API returned invalid or empty process data.");
            }
        } else {
            console.warn("Invalid response from Smart Preset API", result);
            if (result.promptFeedback) {
                throw new Error(`API call blocked: ${result.promptFeedback.blockReason}`);
            }
            throw new Error("Invalid response structure from API.");
        }
    } catch (error) {
        console.error("Error in getLLMSmartPreset:", error);
        // --- MODIFICATION: More detailed alert ---
        alert(`Failed to generate processes: ${error.message}. Check the console for more details.`);
        // --- END MODIFICATION ---
    } finally {
        button.disabled = false;
        button.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;"><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z"/><path d="M5 3v4"/><path d="M19 17v4"/><path d="M3 5h4"/><path d="M17 19h4"/></svg>
            Generate Processes`; // Reset button text
    }
}

    </script>
</body>
</html>